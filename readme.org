#+title: Lisp, Numbers, and Text
#+author: Eric Gustafson

* Goal

  To create a package that will make it easy to convert between
  numerical objects and textual representations of those objects in
  common lisp.

  I'm using this package to work with numbers comming from a
  POSIX/Unix systems for scripting, systems programming, and network
  monitoring.


* Reference

  [[http://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/chapter18.html][Logical Ops in Lisp]]

  ldb, ash

* Example Usage

** Dotted to sequence
  Turn dotted notation into a vector, increment the last octet and 
  turn it back into dotted.

#+BEGIN_SRC lisp :exports both
  (trivia:match
      (nums-and-txt:dotted->vector "1.2.3.4")
    ((vector a b c d)
     (nums-and-txt:addr->dotted (vector a b c (+ d 1)))))
#+END_SRC

#+RESULTS:
: 1.2.3.5


** Numerical Reflection
#+BEGIN_SRC lisp :exports both
  (num->dotted (octets->num (dotted->vector "1.2.3.4")))
#+END_SRC

#+RESULTS:
: 1.2.3.4


** Num to Octets
   Num->octets converts a machine number into big-endian octet list
#+BEGIN_SRC lisp  :exports both
  (list (num->octets 259)
        (num->octets 259 :length 4))
#+END_SRC

#+RESULTS:
| 1 | 3 |   |   |
| 0 | 0 | 1 | 3 |


** Dotted to number
#+BEGIN_SRC lisp :exports both
   (let ((v (nums-and-txt:dotted->num "1.2.3.4")))
     (incf v 5)
     (nums-and-txt:num->dotted v))
#+END_SRC

#+RESULTS:
: 1.2.3.9



** Edge Cases
   Let's try and break things
#+BEGIN_SRC lisp :exports both
   (let ((num (octets->num (dotted->vector "255.255.255.255"))))
     (incf num)
     (num->octets num))
#+END_SRC

#+RESULTS:
| 1 | 0 | 0 | 0 | 0 |





* Compare/Contrast
** Bitsmasher

* TODO Work
  - [ ] remove ip.lisp from snot
  - [ ] predicates for private address
  - [ ] range functions for private addresses
